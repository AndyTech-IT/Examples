//
// Итак всем привет! Сегодня я постараюсь более подробно рассказать вам про такие вещи как: print_f(), scan_f()
// Так же зацеплю все базовые вещи
// При ознакомлении старайтесь не заучить, а понять!
// 
// Поехали!
//

#include <stdio.h>

#include <Windows.h>

#include <iostream>
using namespace std;


#include "main.h"

//
// Начнём с "точки входа" в приложение
// В случае с проектами на С++ это функция под названием main
// Что такое функция разъясню чуть позже 
// А пока: наш код начинает выполнение со следующей после "void main() {" строки 
//

void main() 
{
#pragma region Тип данных Переменная Литерал Оператор Объявление Инициализация
	//
	// Ниже аоказана "переменная" - проименеованная область оперативной памяти вашего устройства
	// Проще говоря ячейка, в которую можно чтото "положить"
	// И на строке 22 она только "объявлена"
	//
	int		variable;
//	 ^			^ 
//	тип 	название 
	//
	// тип - маркер, который обозначает то какие данные может хранить переменная
	// И от того какого типа переменная напрямую зависит то что вы с ней можете сделать
	// На будущее скажу что тип переменной может быть базовым, или пользовательским, тоесть созданным программистом, а не создателем языка
	// Но пока трогать классы и структуры не станем, остановимся на базовых, тк непоняв этой темы с ними делать нечего...
	// 
	// Название - ключевое слово, по которому вы обращаетесь к той самой области памяти и программа, считывает или записывает туда данные
	// Правда рассказать весь процесс я не могу, да и нет необходимости...
	// Скажу что у переменной есть адрес в памяти, который выделяется Опирационной Системой (ОС)
	// 
	// Теперь что значит фраза: "объявление переменной"?
	// Это значит что в конкретнойм месте кода мы создали переменную, и теперь она доступна для обращения к ней
	//

	//
	// Но с только объявленной переменной многово не сделаешь... Ибо там тольлко "мусор"
	// Вот такой он С++... даже "проинициализировать" её начальным значением не соизволит...
	// Всё прийдётся делать самому:
	variable = 0;
	// Вот так! строкой выше я скомандовал записать в переменную значение 0, и тк эта запись первая, можно назвать эту процедуру инициализацией

	// Но переменные потому и названы так, потому что их можно менять! 
	// В нашем случае мы можем изменить значение на другое, соответствующие типу данных этой переменной!
	// Как это происходит? Смотрите ниже:
	variable =			12 - 5 * 2 / 3.5f + '0';
	//	^ 	 ^			^    ^   ^    ^      ^
	// Имя  оператор			Литералы
	//	   присвоения	   ^   ^   ^      ^
	//							Операторы
	// 
	// Литерал это данные, не имеющие имени... их место могут занимать другие переменные
	// Выше приведены литералы целочисленные, дробный и символьный
	// Но результат выражения всюравно будет целочисленный... тк другой тип записать в нашу переменную нельзя!
	// В случае с символьным он преобразуется в код из ACII таблицы, а дробный лишится дробной части...
	// Но не сразу, тут на сцену выходят прераторы
	// Оператор - синтаксическая конструкция языка, которая чтото делает с переменной/литералом
	// К примеру оператор + сложит значения слева и справа от него...
	// Но каждый из них будет выполнятся поотдельности в соответсвии с приоритетом
	// Рассмотрим их в блоке ниже
	// 
#pragma endregion

#pragma region Оператор Функция Перегрузки
	//
	// Оператор как говорилось в конце прошлого блока синтаксическая конструкция
	// которая по сути своей является функцией... да думаю тут стоит о них и рассказать...
	// 
	// И так функция: в трёх словах это проименованный блок кода 
	// Функция ДОЛЖНА выполнять какуюто отведённую ей задачу, и желательно только её.
	// Тут я ещё задену тему нейминга, называйте вещи своими именами! 
	// Хороший код не нуждается в коментировании, поэтому приучайте себя называть переменные, функции, классы ПРАВИЛЬНО в соответсвии с KodeStyle
	// Да писать x1, i, j, k, l1 и b2 быстро... но учтите что проще в имени отразить задачу переменной, а не держать её в голове
	// А если вы его забудите? и потом потратите дофига времени отвечая себе на вопрос, а что это за ascw_1 на 1544 строке... 
	// 
	// Чтото я заболтался...
	// Итак функция. Нажмите на её имя с зажатым Ctrl чтобы "перейти к её определению"
	// P.S. Цель моего рассказа показать что функция есть, и на её примере показать работу оператора
	int Summ(int left_number, int right_number);

	// Теперь "Вызовим" функцию Summ
	int result = Summ(2, 5); // => 2 + 5 = 7
	// и полученное чило 7 записалось в result

	// Так же работают и операторы
	result = 2 + 2 + 4 / 2; // Но учитывается приоритет!
	// В случае с вызовом функций приоритет строго определяется вами
	result = Summ(Summ(2, 2), 4 / 2);

	// Но учтите операторы могут быть "Перегружены", как и функции
	// Это значит написав синтаксически равные конструкции результат может оказаться разным
	// Но вам тут боятся пока нечего, у базовых типов перегрузка операторов не значительная
	// Толька типовая перегрузка, иными словами, подберается такой её вид, который имеет схожий "прототип"
	// Вернёмся к нашей сумме. Перегрузим функцию для типа double: имя одно, реализации две
	double Summ(double left_number, double right_number);
	// И теперь вот ситуация, мы пытаемя поделить 3 на 2
	// 3 - целочисленный литерал и 2 - тоже, а значит и результат будет целочисленая 1, но никак не 1.5, остаток обреждет наш оператор
	double ratio_of_threeand_two = 3 / 2;
#pragma endregion

	// Ну и перейдём к, наверное, ГЛАВНОЙ теме которую я хотел раскрыть!
	// Чтож это за зверь то такой printf и его собрат scan_f!
	// Но! мы не сможем их применять не подключив нужную библиотеку stdio.h
	int a = printf("Hello World!\n");
	printf("%d\n", a);
	// Узнали синтаксис? Да это процедура! Но она возвращает число напечатаных в уонсоль символов
	// Спец символы тоже считаются!!
	// Но это так, фантики... Давайте к делу!

	// Зачем нужен printf? Выводить в консоль данные
	// С чем так же может справится и обычный cout (си аут, не каут!!!)
	// И тут стоит напомнить, что в программировании НЕТ ЕДИНОГО ВЕРНОГО РЕШЕНИЯ! 
	// Не устану повторять: пишите код так, как вам это удобно! А если это комуто не нравиться, пусть напишет сам так как ему надо!
	// И тут же ремарка, всёже стоит иногда прислушиваться к чужёму мнению, но и слепо слушать чужим придиркам не выход... 
	// Тема немного филосовская, а мы тут технологию изучаем...
	// 
	//  И так, почему printf а не cout? 
	// Хороший вопрос! и на самом деле ни тот не другой не лучше другово, просто у них разный "интерфейс" 
	// И один будет удобен в одном случае, а второй в ином
	// Не буду голословен, и вот пример:

	cout << "Hello, I am 20\n";
	char hello[] = "Hello, I am";
	int age = 20;
	cout << hello << " " << age << endl;
	printf("%s %d\n", hello, age);
	printf("Hello, I am %d\n", age);

	// Хм, вроде такой простенький пример а уже сколько возможных реализаций
	// Разберём по подробнее: первая реализация - вывод статичного текста, его трудно будет связать с кодом...
	// Вот стукнет мне 21 и что? искать все строки где присутствует мой возрат и править их?
	// Таже логика и с преветсвенным сообщением, вдруг я его захочу менять в зависимости от времени суток, но это всё украшательства и улучшения кода...
	// 
	// Сконцентрируемся на различиях, а их почти нет, я вывел один и тотже текст 4 раза...
	// Поэтому выбор уже строится на факторе стиле кода и вкуса программиста
	// Мне больше приятен обычный cout, всё по порядку и локанично, а не так что в начале шаблонная строка а потом значения...
	// Но если уж на то пошло, я всёже склонюсь к синтаксису C# и вот она похожа на printf:
	// Console.WriteLine(f"Today I have {money:.2f} руб.");
	// Ну красота же! Красиво лаконично, и удобно! А самое главное это работает не только при выводе в консоль, а в любой момент так меожно строить строки!
	// 
	// Но вернёмся к С++... а тут только его уродливый предок printf...
	// Итак как его использовать: Суть его работы проста, вводите патерн строки, так называемый "формат"
	// А в последующие аргументы функции передаёте данные которые она впишет вместо %d %c и прочего...
	// Думаю самописная (копи паст с вики) процедура будет наглядным пособием по которому можно будет пройтись в отладчике!

	print_f("Hello World! 100%%\n");	// Те кому интересно пройдитесь в отладчике поствив точку остановки тут и используйте "шаг с заходом"
	print_f("3 / 2 = %d\n", 3 / 2);
	print_f("3 / 2 = %d\n", 3.0 / 2);
	print_f("3 / 2 = %f\n", 3.0 / 2);

	// Ну всё работает как оригинал... только как сказал автор %6.3f работать не будут...
	// scanf работает по той же логике... или не совсем... давайте эксперементировать дальше!
	/*int input;
	a = scanf("%d", &input);
	cout << a << input;*/
	// Ага, ну да ну да:
	// Ошибка	C4996	'scanf': This function or variable may be unsafe.Consider using scanf_s instead.To disable deprecation, use _CRT_SECURE_NO_WARNINGS.See online help for details.Examples	C : \Users\akoko\!My_Folder\I_Teacher\CppProgects\Examples\main.cpp	169

	// В общем на этом пока всё, на выходных поломаю голову над этой проблемой...

	system("pause");
}

#pragma region Функции Summ
//
// Итак функция, она принимает аргументы и возвращает какоето значение в результатае своей работы
// В нашем случае Summ принимает 2 целочисленны[ аргумента: left_number и right_number
// И как бы по названию понятно что функция должна их сложить и вернуть результат сложения
//
int Summ(int left_number, int right_number) {
	// Так же работает оператор +, его мы и используем
	int result =  left_number + right_number; // == int result = Summ(left_number, right_number)
	// Оператор от функции отличается лишь синтаксисом

	// Ниже тоже оператор, return возрращает результат работы функции и прерывает её выполнение
	return result;

	// Можно записать иначе 
	// и нет этота строка кода никогда не выполнятся XD
	return  left_number + right_number;
}
double Summ(double left_number, double right_number) {
	return left_number + right_number;
}
#pragma endregion

void print_f(const char *s)
{
    while (*s) {
        if (*s == '%') {
            if (*(s + 1) == '%') {
                ++s;
            }
            else {
                throw std::runtime_error("неправильный формат строки: отсутствуют аргументы");
            }
        }
        std::cout << *s++;
    }
}

template<typename T, typename... Args>
void print_f(const char *s, T value, Args... args)
{
    while (*s) {
        if (*s == '%') { // Поиск символа %
            if (*(s + 1) == '%') { // Если он дублируется: "%%"
				cout << '%';
                ++s;
            }
            else {
				switch (*(s+1)) // Свичим символ после %_
				{
				case 'd':		// Целочисленный вывод
					std::cout << (int)value;
					break;
				case 'f':		// ВЫвод дробного числа
					cout << (float)value;
					break;
				default:
					cout << value;
					break;
				}
				// перепрыгиваем на 2 символа тк счётчик на позиции перед %
                s += 2; /// работает только для спецификаторов формата из двух символов (напр. %d, %f ).Не будет работать с %5.4f

				// А вот это уже рекурсия! как нибудь потом растолкую, но суть в том что он дойдя до первого % выводит переменную value
				// И потом вызывает себя с обрезоной строчкой, а тк функция имеет "вариативный шаблон" (пока просто "магия")
				// место value занимает следующая переменная а остальные ждут своей очереди в args
                print_f(s, args...); /// вызов происходит даже когда *s == 0, чтобы обнаружить избыточные аргументы
				// Это выглядит так:
				// 1 - print_f("%d %f %c\n", value = 2, args = [1.5, 'H']);
				// Вывод >> 2;
				// Пробел;
				// 2 - print_f("%f %c\n", value = 1.5, args = ['H']);
				// Вывод >> 1.5;
				// Пробел;
				// 3 - print_f("%c\n", value = 'h');
				// Вывод >> H;
				// 4 - print_f("\n");
				// Перенос строки;
				// return;
                return;
            }
        }
        std::cout << *s++;
    }    
}