#include <Windows.h>
#include <stdio.h>
#include <iostream>
#include <cstdio>
#include <chrono>
#include <thread>
#include <stdlib.h>

using namespace std;

#pragma region Первый Семестр

// Забыл как называется, но тут оно для того, чтобы НЕ компилировались те строки, которые вызовут исклучение
#define SAVE

// namespace - Отдельное пространство имён недоступное из вне, без обращения к его имени.
// я его тут использую чтобы отделить его от другого кода
namespace Functions 
{
	void foo();	// Прототип функции
	void foo()	// Описание функции
	{
		cout << "bar";
	}

	// 100% копия foo
	void foo2() 
	{
		cout << "bar";
	}


	void func1(int, int);	// Так можно
	void func1(int x, int y) 
	{ }

	void func2(int, int)	// Так тоже, нооо
	{ }


	void F1() 
	{
#ifndef SAVE

		F2();	// F2 объявлен ниже по коду поэтому вызвать её сейчас нельзя

#endif // SAVE
	}

	void F3();

	void F2()
	{
		F1();	// А вот F2 вызвать F1 может, тк он был объявлен выше
		F3();	// В свою очередь F3 вызвать можно, тк выше есть его прототип
	}

	void F3() {};


	int A(int a) 
	{
		return ++a;
	}

	int B(int b) 
	{
		return A(++b);
	}
}

#pragma region Arrays

/// Копирует часть элементов из массива "copy" в массив "paste"
/// copy_count - число элементов (начиная с индекса 0) которые будут скопированны во второй
void copy(int* copy, int* paste, int copy_count);

// Создаёт новый массив, копирует в него данные из старого, записывает в конец массива "number"
void append(int* &mass, int& size, int number);

void Arrays() 
{
// Отвечает за компиляцию первого примера
// Закоментируй или удали строку ниже, и связванный с ней блок кода не скомпилируется, а значит не будет выполнен!
#define PREVIEW_1
#ifdef PREVIEW_1

	int a;				// Вот переменная типа int
	a = 1;				// А вот мы её инициализировали как 1
	cout << a << endl;	// .. и вывели на экран

	int* b;				// Вот указатель на переменную типа int
	b = new int(2);		// Вот мы выделили память из кучи для переменной типа int и записали в неё 1
	cout << *b << endl;	// .. и вывели переменную на которую указывает "b" на экран

	delete b;			// А вот тут освободили ячейку памяти в куче, если так не делать будет утечка памяти

	b = &a;				// А вот тут мы сделали так чтобы "b" указывал на "a"
	a = 3;				// Изменим значение a для наглядности
	cout << *b << endl;	// .. и вывели переменную на которую указывает "b" на экран

#ifndef SAVE
	delete b;			// В этом случае очищать память нельзя! Т.к. "a" в статической памяти программы, а не в куче!
#endif // !SAVE

#endif // PREVIEW_1

// Отвечает за компиляцию второго примера
#define PREVIEW_2
#ifdef PREVIEW_2

	// А теперь когда немного показал правила работы с указателями перейдём к массивам

	int mass[3];	// Вот переменная типа int.. или стоп не совсем, это массив из 3-х переменных типа int

	// Выведим массив в цикле..
	for (int i = 0; i < 3; i++)
		cout << mass[i] << ' ';
	cout << endl;
	// .. упс, забыли проинициализировать, итог: на экране мусор!

	// Исправим это...
	mass[0] = 1;
	mass[1] = 2;
	mass[2] = 3;

	// ... и повторим вывод на экран
	for (int i = 0; i < 3; i++)
		cout << mass[i] << ' ';
	cout << endl;

	/*
	Хорошо, но слишком много строк кода было задействовано...
	Сократим запись
	*/
	// Новый массив...
	int mass1[]{ 3, 2, 1 };

	// Выведим массив в цикле..
	for (int i = 0; i < 3; i++)
		cout << mass1[i] << ' ';
	cout << endl;

#endif // PREVIEW_2

// Отвечает за компиляцию перевой задачи
#define TEST_1 
#ifdef TEST_1	

	/*
	А теперь задача!
	Надо сосчитать сколько денег у пользователя.
	*/
	// Легко!

	// Балланс пользователя
	int money = 0;

	// Число монет
	int n;
	cout << "Couns count: ";
	cin >> n;

	for (int i = 0; i < n; i++)
	{
		// Номинал монеты
		int coin_cost;
		cout << "Coin " << i + 1 << " : ";
		cin >> coin_cost;
		money += coin_cost;
	}
	cout << "You have " << money << " money." << endl;

#endif // !TEST_1

// Отвечает за компиляцию первой версии второй задачи
#define TEST_2_1
#ifdef TEST_2_1

	// Но вот незадача, нужно посчитать количество монет каждого номинала.
	// Да если у нас монеты реальные номиналом 1, 2, 5, 10 то тут нет никаких проблем. А если монеты могут быть от 1 до 1000?
	// Данная задача резко возрасла в сложности, тем что надо соотнести каждую монету её количесвом
	// Вдабавок мы не знаем того сколько монет у пользователя и сколько уникальных манет будет...
	// Чтож попробуем использовать массив из 1000 элементов для подсчёта числа монет каждого номинала

	// Инициализируем массив заполняя его нулями
	int coin_counts[1000] { 0 };	// Число манет каждого номинала

	// Число всех монет
	int n1;
	cout << "Couns count: ";
	cin >> n1;

	for (int i = 0; i < n1; i++)
	{
		// Номинал монеты
		int coin_cost;
		cout << "Coin " << i + 1 << " : ";
		cin >> coin_cost;
		coin_counts[coin_cost]++;
	}
	// Осталось пройтись по массиву и вывести его не нулевые элементы
	for (int i = 0; i < 1000; i++)
	{
		int count = coin_counts[i];
		if (count != 0)
			cout << i << ": x" << count << endl;
	}
#endif // TEST_2_1

// Отвечает за компиляцию второй версии второй задачи
#define TEST_2_2
#ifdef TEST_2_2

	// Правда у нас получается следующая ситуация, пользователь врятли будет использовать все типы монет, а массив наш будет всегда на 1000 элементов.
	// Поэтому давайте используем другой метод...

	// Массив монет
	// coins[i][0] - номинал монеты
	// coins[i][1] - количество монет этого номинала
	int** coins;				

	// Число номиналов текущих монет пользователя
	int coins_type_count = 0;

	// Число монет
	int n2;
	cout << "Coins count: ";
	cin >> n2;

	// Инициализируем массив размером с число монет, тк это максимальное число уникальных монет
	coins = new int* [n2];
	for (int i = 0; i < n2; i++)
	{
		// Номинал монеты
		int coin_cost;
		cout << "Coin " << i + 1 << " : ";
		cin >> coin_cost;

		// Флаг символизирующий наличие номинала монеты в массиве
		bool found = false;
		for (int j = 0; j < coins_type_count; j++)
		{
			if (coins[j][0] == coin_cost)
			{
				coins[j][1]++;
				found = true;
				break;
			}
		}

		if (found == false) 
		{
			coins[coins_type_count++] = new int[2] {coin_cost, 1};
		}
	}

	for (int i = 0; i < coins_type_count; i++)
	{
		cout << coins[i][0] << ": x" << coins[i][1] << endl;
	}

	// Не забываем отчищать память, да С++ сам этого не умеет...
	for (int i = 0; i < coins_type_count; i++)
	{
		delete[] coins[i];
	}
	delete[] coins;

#endif // TEST_2_2

// Отвечает за компиляцию третьего примера
#define PREVIEW_3
#ifdef PREVIEW_3

	// Ну а теперь самая главная беда С++...
	// Статичность всех, абсолютно всех базовых массивов

	/*Вот смотрите есть массив :*/	int* arr = new int[3]{ 1, 2, 3 };	delete[] arr;
	// Массив динамический, но добавить в него 4тый элемент мы просто так не можем
	// для этого надо пересоздать массив уже с размером 4, скопировать в него все элементы из старого и записать в последюю ячейку новый элемент
	// И копирование прийдётся тоже писать самому.
	// Ну давайте напишем это!

	int size = 5;
	int* arr1 = new int[size];
	for (int i = 0; i < size; i++) 
	{
		arr1[i] = i;
	}

	for (int i = 0; i < size; i++) 
	{
		cout << arr1[i] << ' ';
	}
	cout << endl;

	append(arr1, size, size);

	for (int i = 0; i < size; i++)
	{
		cout << arr1[i] << ' ';
	}
	cout << endl;

	delete[] arr1;

#endif // PREVIEW_3
}

void copy(int* copy, int* paste, int copy_count) 
{
	for (int i = 0; i < copy_count; i++) 
	{
		paste[i] = copy[i];
	}
}

void append(int* &mass, int& size, int number) 
{
	int* result = new int[size + 1]{};	// Новый массив на 1 элемент больше зтарого

	copy(mass, result, size);			// Копируем значения из старого в новый

	result[size++] = number;			// Записываем "number" в конец новго массива

	delete[] mass;						// Удаляем старый массив

	mass = result;						// Перепривязываем указатель старого массива на новый
}

#pragma endregion

#pragma region Strings

#include <string>
#include <string.h>

void Strings() 
{
//#define EXAMPLE_1
#ifdef EXAMPLE_2

	// Итак, теперь поговорим о строках...
	// На самом деле тут нет ничего сложного, строка - массив символов.
	// но прежде чем поговорить о строках, поговорим о символах

	char c = 'c'; // Создадим символьную переменную, и передадим в неё символ 'c'
	// А теперь выведем её на экран двумя спосабами, первый как символ, а второй как число
	printf_s("Key - %c, Code - %i\n", c, c);	// Тут стоит впомнить про кодировку ASCII
	// Уяснили, символ = число, только другого типа

	// Зная это сделаем кое что не логичное..
	cout << "ASCII table:" << endl;
	for (int i = 0; i < 256; i++)
		printf_s("Key - %c, Code - %i\n", i, i);

	// Что получилось? Да в консоль вывелась вся таблица ASCII
	// Но запомнить код каждого символа, весьма глупая затея...
	// Но что делать если надо вывести весь алфавит?
	// Нууу, вы же помните что символ = число?
	// Тогда кто мешает сделать так?
	cout << "ABC:" << endl;
	for (int i = 'A'; i <= 'Z'; i++)
		printf_s("Key - %c, Code - %i\n", i, i);

	// Занятно, да?
	// Ну чтож, надеюсь этого хватит для начала...

#endif // EXAMPLE_2

	// Итак строки, начнём с простого:
	char str[] = "Some text\n";
	printf_s(str);

	// Но стоит помнить что строка константна, и её менять в коде нельзя..
#ifndef SAVE
	str = "";
#endif // SAVE

	// Вы же помните динамические массивы?
	// Ну вот, тут тоже можно так сделать!
	char* str1 = new char[] {"Line\n"};
	printf_s(str1);
	delete[] str1;

	// Но и тут есть нюансы...					 
	str1 = new char[] {'L', 'i', 'n', 'e', '\n', '\0'};
	printf_s(str1);								// ^ Вот без этой штуки, вас ждёт исключение!
	delete[] str1;

	// Что такое '\0'? - спросите вы меня..
	// Нуль терминатор - отвечу я
	// Это сивлол конца строки (не путайте с символом переноса строки!)
	// Если инициализировать посимвольно, вы обязаны его добавить!
	// Если через "" то \0 поставят за вас!
	char str2[] = "";	// Обратите внимание! Размер массива 1, хотя между "" ничего нет!

	// Но что будет если его поставить не в конце строки, а гдето посередине?
	// Ну вот что...
	str1 = new char[] {'H', 'e', 'l', 'l', 'o', ' ', '\0', 'W', 'o', 'r', 'l', 'd', '\0'};
	printf_s(str1); cout << endl;	// Тадааам, строку обрезало на середине!
	delete[] str1;

	// Ну и на последок держите цикл for each в C++
	for (char c1 : "Hello world!")
	{
		if (c1 == '\0')
			cout << endl;
		else
			cout << c1;
	}

	// Чтож, теперь нюанс, в С++ по умолчанию со строками работать нельзя, строка - массив символов
	// Иначе говоря, С++ не видит строку как отдельный тип данных, а значит (str + str) незя..
	// Тут на помощь приходит класс string из одноимённой библиотеки

	// И уже это можно считать, полноценной строковой переменной
	string string1 = "Hello";
	string1 += " world!";
	cout << string1 << endl;

	// Тут стоит рассказать для начала что такое классы, методы, операторы и тд...
	// но, это как нибудь потом, пока что просто запомните синтаксис
	// Всю информацию беру с статьи:
	// https://server.179.ru/tasks/cpp/total/161.html
	
	// Начнём с конструкторов - способов инициализации
	// Строки можно создавать с использованием следующих конструкторов:
	// string() - конструктор по умолчанию(без параметров) создает пустую строку.
	// string(string & S) - копия строки S
	// string(size_t n, char c) - повторение символа c заданное число n раз.
	// string(string & S, size_t start, size_t len) - строка, содержащая не более, чем len символов данной строки S, начиная с символа номер start.
	
	// Итак потестируем:
	string string2 = string();
	printf_s("%s\n", string2.c_str());

	string2 = string(string1);
	string2 += " I love C++";
	printf_s("Source string - %s\n", string1.c_str());
	printf_s("Copy string - %s\n", string2.c_str());
	
	string2 = string(10, '%');
	printf_s("%s\n", string2.c_str());

	string2 = string(string1, 6, 5);
	printf_s("%s\n", string2.c_str());

	// Конструктор, можно считать специальной процедурой, а значит, можно делать так:
	string2 = string(5, '@') + ' ' + string1 + ' ' + string(5, '@');
	printf_s("%s\n", string2.c_str());

	// Конечно же вы заметили что я использую операторы сложения и присваивания?
	//	Со строками можно выполнять следующие арифметические операции :
	//	= -присваивание значения.
	//	+= -добавление в конец строки другой строки или символа.
	//	+ -конкатенация двух строк, конкатенация строки и символа.
	//	== , != -посимвольное сравнение.
	//	<, >, <= , >= -лексикографическое сравнение.

	// Первые 3 я использовал, так что тепереь посмотрим на оставшиеся:
	string1 = "Hello";
	string2 = "hello";
	string1 == string2 ? printf("True") : printf("False");	cout << endl;

	string2 = "Hello world";
	cout << string1 << " > " << string2<< " - " << (string1 > string2) << endl;
	cout << string1 << " < " << string2 << " - " << (string1 < string2) << endl;
	cout << string1 << " >= " << string2 << " - " << (string1 >= string2) << endl;
	cout << string1 << " <= " << string2 << " - " << (string1 <= string2) << endl;

	// Ну а теперь самое сладенькое!
	// Методы объектов класса string:
	// Их ооочень много, и их описание (если хотите) прочитайте в статье которую я упоминул выше

	// Но разберём основные из них!

	int size1 = string1.size();
	int size2 = string1.length();
	int size3 = strlen(string1.c_str());

	printf(".size() - %i\n", size1);
	printf(".length() - %i\n", size2);
	printf("strlen() - %i\n", size3);

	string2 = string(string1);
	cout << "Source string: " << string2 << endl;

	string2.append("@");
	cout << ".append('@') - " << string2 << endl;

	string2.append(4, '&');
	cout << ".append(4, '@') - " << string2 << endl;

	string2.append("12345", 1, 3);
	cout << ".append(\"12345\", 1, 3) - " << string2 << endl;

	// Ну и для тех кто любит выпендрёжный синтаксис, держите!
	string2 = string(string1).append("@").append(4, '&').append("12345", 1, 3);
	cout << "string(string1).append(\"@\").append(4, '&').append(\"12345\", 1, 3) - " << string2 << endl;

	string2.insert(0, string(5, '@'));
	cout << ".insert(0, string(5, '@')) - " << string2 << endl;

	// Ну и теперь настоящая магия!
	string2 = "Hello world!";
	string find = "world";
	string replace = "C++";
	int index = string2.find(find);
	string2.erase(index, find.length());
	string2.insert(index, replace);
	cout << string2 << endl;
}

#pragma endregion

#pragma region How to code?
void HowToCode()
{
	// Итак, я рассказал вам о базовых инструментах языка С++, их должно хватить для написания простеньких программ
	// Остался последний вопрос - как запрограмировать алгоритм? иначе говоря как кодить?
	// Тут больше идёт не знание языка а логическое мышление, если его не хватает то тут пригодятся базовые алгоритмы 
	// (загуглите эту тему если интересно: Алгоритмы С++)
	// Лично я придумываю все алгоритмы находу, и получалось неплохо...
	
	// Задача, найти максимальное число в массиве:

	int max = 0;					// Максимальное число инициализируем как минимально возможное
									// чтобы не было так что это число больше чем любой элемент массива
	// количество элементов в массиве
	const int mass_size = 6;
	// Массив чисел, в котором осуществляется поиск
	int mass[mass_size]{4, 5, 6, 1, 7, 0};
	// Цикл поиска максимального числа
	for (int i = 0; i < mass_size; i++)
	{
		if (mass[i] > max)
			max = mass[i];
	}
	cout << max << endl;
	// Алгоритм крайне прост! но его можно написать поразному...

	max = 0; // Сбросим значение вновь до 0

	// Аналогичный цикл поиска
	for (int num : mass) max = num > max ? num : max;
	cout << max << endl;

	// Ещё вариант
	max = 0;
	int* num = begin(mass);
	while (num < end(mass))
	{
		*num > max ? max = *(num++) : *num++;
	}
	cout << max << endl;

	// Все они работают абсолютно одинаково, только использются разные инструменты языка
	// И вполне обоснованна тогда проблема трудности проектирования программы
	// она может быть реализованна всевозможными способами!
	// поэтому уместно высказываение: 
	// "Чтобы научится программировать - начни программировать!"
	// а алгоритм работы программиста-специалиста от новичка почти не отличается
	// 
	// while (code.working == false)
	// {
	//		programerr.write(code);
	// }
	// 
	// отличие только в опыте:
	//  = у вас только десяток лабораторок
	//  = у меня свыше сотни лабораторок, почти десяток курсовых и несколько дипломов (мои + моих однокурсников из колледжа)
	// 
	// и вы так же как и я после прочтения задания понятия не имеете как писать код
	// 
	// И вот потом начинаются различия:
	//  = Я могу начать сразу писать код, пробывать разные идеи, исходя из своего опыта
	//  = Вам же будет проще начать с сёрфинга в гугле, найти там подходящее решение, или хотябы идею для реализации
	//    ВАЖНО! не тупо скопировать, вставить и сдать, а обязательно понять как оно работает например: 
	//	-	изменить условие на противоположное
	//	-	изметнить количество и значение вводных данных
	//	-	попробывать сломать код, чтобы он перестал работать правлино, или вызвал исключение
	// 
	// всё это, возможно, пригадится вам в будующем, и вам не прийдётся снова обращатся в гугл, чтобы понять как выполнить аналогичную задачу
	// И вновь повторюсь, пишите код! то что вы возмёте готовый не даст вам опыт, а значит ползы вы не получили и потратили время зря
	// 
	// Так, а вы поните что я писал:
	//	Хм, я тут подумал... И решил, напишу КА я для вас свой универсальный метод проектирования любого кода😇
	//	Итак первый шаг :
	//	"Постановка задачи" для начала надо определиться что надо, и представить как этого можно достич
	//	Шаг второй :
	//	"Гуглинг аналогов" с некотором шансом найдёте пару тройку проектов похожих на ваш
	//	Шаг третий :
	//	"Гуглинг модулей", да возможно вы найдёте модули из которые ускорят разработку
	//	Шаг четвёртый :
	//	"Программирование" Собираем всю собранную информацию в кучу и пробуем закодировать так чтобы оно работало
	//	P.S.Если вдруг возникают трудности и / или что - то не работает, опрашиваем гугл, если не находим решение проблемы(что тоже возможно) обращаемся к более опытному в этой сфере(только если гугл вам не помог!)
	// 
	// Так вот, давайте разберём одну задачку по этим шагам:
	// Задача: Написать программу, которая отчистит строку от символов препинания, лишних пробелов и все буквы будут строчными
	// 
	// Первый шаг - "Постановка задачи":
	// здесь надо определить как должна работать ваша программа, для её тестирования
	// нам нужна программа которой на вход подают предложение (массив смволов который можно разбить на слова, разделённый знаками препинания)
	// результатом работы программы должна быть такая строка, в которой нет знаков препинания, и все слова разделены только одним пробелом
	// 
	// Пример 1: 
	// Ввод: Привет мир!
	// Вывод: привет мир
	// 
	// Пример 2:
	// Ввод: Привет, мир С++!
	// Вывод: привет мир с
	// 
	// Пример 3:
	// Ввод: П,П,,Р - Р
	// Вывод: п п р р
	// 
	// Готово!
	// 
	// Шаг второй - Гуглим аналоги:
	// Оставлю на вас =)
	// 
	// Шаг третий - Гуглинг модулей:
	// Применю библиотеку string, для упрошения работы со строками
	// 
	// Шаг четвёртый - Кодим! 
	
	// Начнём с ввода:

	string line;			// Исходная строка
	cout << "Enter the string: ";
	getline(cin, line);

	// Далее надо разбить строку на слова

	string clear_words;		// Строка отчищенных слов
	char last_c = line[0];
	for (char c : line)		// Найдём их в цикле
	{
		// Копирует пробел если предыдущий символ был буквой/цифрой
		if (c == ' ' && isalnum(last_c))
		{
			clear_words += c;
			last_c = c;
			continue;
		}

		// Копирует букву в нижнем регистре
		if (isalnum(c))
		{
			if (isalnum(last_c) == false && last_c != ' ')
				clear_words.append(" ");
			clear_words += tolower(c);
		}
		last_c = c;
	}

	cout << clear_words << endl;

	// Ну как то так...
	// Последнее что хотелось сказать, не стесьняйтесь смотреть примеры коды, смотреть чужёй код, это полезно, узнать как другие программируют!

}
#pragma endregion

#pragma region Exam
int foo() { cout << "foo" << endl; return 0; }
void bar(int a) { cout << a << endl; }

int Foo(int (*func)(int), int a) { return func(a) + 1; }
int foo1(int a) { return a + 1; }
int foo2(int a) { return a - 1; }

// Да, не забываем про области видимости...
// Пришлось дублировать код...

typedef bool(&ValidateInt)(int);
using ValidateFloat = bool(&)(float);

bool Bar(int a, ValidateInt validate) { return validate(a); }
bool BAR(float a, ValidateFloat validate) { return validate(a); }
bool bar1(int a) { return a > 1; }
bool bar2(float a) { return a > 0.5; }

namespace SPACE_A { int a = 4; }

// Часть 1. Теоретические вопросы
void Part_1()
{
	// Тема 1. Основы алгоритмизации
	// 
	// 1)
	// Программа - Алгоритм, последовательность комманд/инструкций/действий
	// Примеры из жизни:
	// Сходи в магазин, купи хлеба, десяток яиц и литр молока. 
	// Инструкция по сборке лего.
	// Расписание уроков или распорядок дня.
	// А в программировании программа = скрипт = код.
	// 
	// Программирование - очевидно что это процесс написания программы.
	// Он включает как непосредственное написание кода, так и проектирование с тестированием.
	// Иначе говоря Программирование = разработка программ(ПО)
	// 
	// Этапы:
	// Как и говорил ранее выделяют 3 основных этапа: 
	//	Проектирование	- Придумывание как куда что зачем и почему.
	//	Реализация		- Написание кода, рисование графики(интерфейс, модели и тд), создание БД и прочее прочее прочее. В общем создание продукта.
	//	Тестирование	- Проверка текущего продукта на соответствие требованиям и отсутсвие критических ошибок(исключений и не плановых выключений программы)
	// 
	// 2)
	// Алгоритм - Это уже строго определённая программа.
	// Грубо говоря "Сходи в магазин" - можно назвать программой, но не алгоритмом. Для того чтобы стать алгоритмом прейдётся понизить уровень абстракции.
	// "Возми на баре карточку, оденься, обуйся, возми сумку, открой дверь, выйди, закрой дверь ..." - Это уже с натяжкой можно назвать алгоритмом.
	// В алгоритме описывается порядок однозначных действий(которые нельзя трактовать по разному) "Купи что-нибудь к чаю" - так нельзя. 
	// 
	// Так, теперь плавно перейдём к свойствам алгоритмов:
	// + Дискретность — алгоритм должен представлять процесс решения задачи как упорядоченное выполнение некоторых простых шагов.
	//		При этом для выполнения каждого шага алгоритма требуется конечный отрезок времени, 
	//		то есть преобразование исходных данных в результат осуществляется во времени дискретно.
	//	*Что я и говорил выше: "Сходи за хлебом" - не алгоритм!
	// + Детерминированность(определённость) - В каждый момент времени следующий шаг работы однозначно определяется состоянием системы.
	//		Таким образом, алгоритм выдаёт один и тот же результат(ответ) для одних и тех же исходных данных.
	//		В современной трактовке у разных реализаций одного и того же алгоритма должен быть изоморфный граф.
	//		С другой стороны, существуют вероятностные алгоритмы, в которых следующий шаг работы зависит от текущего состояния системы и генерируемого случайного числа.
	//		Однако при включении метода генерации случайных чисел в список «исходных данных» вероятностный алгоритм становится подвидом обычного.
	//	*Опять же - "Купи чтото к чаю" - не алгоритм!
	// + Понятность — алгоритм должен включать только те команды, которые доступны исполнителю и входят в его систему команд.
	//	*Тут всё просто, у каждого исполнителя есть свой "синтаксис" комманд, который нельзя нарушать.
	// + Завершаемость(конечность) — в более узком понимании алгоритма как математической функции, 
	//		при правильно заданных начальных данных алгоритм должен завершать работу и выдавать результат за определённое число шагов.
	//		Дональд Кнут процедуру, которая удовлетворяет всем свойствам алгоритма, кроме, возможно, конечности, 
	//		называет методом вычисления(англ.computational method).
	//		Однако довольно часто определение алгоритма не включает завершаемость за конечное время.
	//		В этом случае алгоритм(метод вычисления) определяет частичную функцию.
	//		Для вероятностных алгоритмов завершаемость как правило означает, 
	//		что алгоритм выдаёт результат с вероятностью 1 для любых правильно заданных начальных данных
	//		(то есть может в некоторых случаях не завершиться, но вероятность этого должна быть равна 0).
	//	*Тут тоже не сложно: бесконечных циклов допускать не желательно, программа должна выполнить свою работу и корректно завершить свою работу.
	// + Массовость(универсальность).Алгоритм должен быть применим к разным наборам начальных данных.
	//	*Тут немного сложно.. Но только по началу, каждая программа, уже по умолчанию подходит для множество типичных задач. 
	//		Под задачей я понимаю даже отличие вводных данных.
	//		Тобеш код: return a; - Уже подходит этому условию XD
	//		Ну тут главное не уйти в филосовствование по поводу повторного использования кода, но обойдёмся без этого...
	// + Результативность — завершение алгоритма определёнными результатами.
	//	*Ну как бы, а зачем ещё писать программу... Есть задача, и программа должна её решать, всё...
	// 
	// Метод пошаговой детализации...
	// Ух, как они круты, ничего про это не говорили, корили меня что декомпозиция и проектирование ещё рано, и вот на тебе оно в экзамене...
	// Кароче, у нас есть задача: "Сходить за хлебом".
	// Как нам её решить(запрограммировать)?
	// Ну во-превых, необходимо собраться, дойти до магазина, купить там хлеб и вернутся домой.
	// Тепреь можно каждый из этих шагов разбить на молее мелкии, таких которые будут соответсвовать свойтву детерменированность.
	// Итак рассмотрим шаг дойти до магазина:
	// Найти все ближайшие хлебные магазины на карте, выбрать из них ближайший, проложить к нему маршрут, следуюя маршруту дойти до магазина.
	// Ну а вот эти шаги уже можно смело программировать. Подключить API гугл карт(например) составить с его помощью массив координат, и построить путь от нашей точки к каждому и тд и тп.
	// 
	// 3)
	// Основные способы записи алгоритма
	// Выделяют следующие основные способы записи алгоритмов: 
	// - вербальный, когда алгоритм описывается на человеческом языке; 
	// - символьный, когда алгоритм описывается с помощью набора символов; 
	// - графический, когда алгоритм описывается с помощью набора графических изображений.
	// Надеюсь тут коментарии не нужны?
	// 
	// Базовые алгоритмические конструкции:
	// + следование - дэфолт, строка за строкой 
	// + ветвление  - if else, switch case (Возможно даже try catch)
	// + повторение	- циклы.. for, while, do wile, foreach...
	// 
	// Теорема Дейкстра.
	// Все имеющиеся алгоритмы можно разделить на три вида:
	//	линейные алгоритмы;
	//	алгоритмы ветвления;
	//	циклические алгоритмы.
	//	Для решения любых задач достаточно этих трех видов алгоритмов!
	// 
	// Понятие «структурное программирование»
	// Структу́рное программи́рование — парадигма программирования, в основе которой лежит представление программы в виде иерархической структуры блоков. 
	// Программы становились слишком сложными, чтобы их можно было нормально сопровождать. 
	// Поэтому потребовалась систематизация процесса разработки и структуры программ.
	// *Проще говоря: Спагети код - плохой, GO TO - грех, самодокументированный код - хорошо, DRY(Dont Repiat Youself - Не повторяйся) - Хорошо.
	//	Сюдаже хотел отнести ещё другие патерны программирования, но блин нам их не давали! А требуют знать то что с ними непосредственно связанно!
	//	Самое главное в этом понятии - НЕ рекомендуется писать всю логику в один большой блок! Суперкласс, Суперметод и тд. Супер они не от того что хорошие,
	//		а от того что делают всё и сразу. Это ОООЧЕНЬ плохо для дальнейшей разработки! В идеале ваш код должен стремится выполнять принципы SOLID нооо, это опять паттерны...
	//		Так что, да...
	//	P.S. Спагетти код - код с запутанной логикой, в котором чёрт ногу сломит и который даже автор не понимает.
	// 
	// Тема 2. Введение в программирование
	// 
	// 4)
	// Язык Программирования или же ЯП - формальный язык, предназначенный для записи компьютерных программ.
	// Давнешний мем, HTML - не язык программирования. ХЫХ, мда.. Всё что надо понимать - мы пишем программы используя тот или иной яп.
	// И такая программа компилируется в исполняемй файл который можно уже запустить на устройстве. (Да есть не компелируемые ЯПы, но об этом потом)
	// Зачем нужны ЯПы? Ну затем чтобы не писать программы на клаве "трупрограммиста" (01000110101101...) Мы не понимаем язык машин, и не не нужно, поэтому придумали ЯПы.
	// 
	// Классификация языков программирования
	// 1. Процедурные языки - В них нет ООП, но есть процедуры и функции, на которых всё и крутится (Самые первые ЯПы) 
	// 2. Языки программирования низкого уровня - С/С++ Язык Асемблера, в общем всё то что может работать напрямую с железом.
	// 3. Языки программирования высокого уровня - Все остальные ЯПы.
	// 4. Объектно-ориентированные языки - Поддерживают ООП (классы методы и прочие ништяки)
	// 5. Декларативные языки программирования - Хоба, откуда не ждали: "К декларативным языкам можно отнести JSON, XML, SQL и HTML c CSS." Пам пам пам... Кароче это япы, но не япы)
	// 6. Функциональные языки программирования - Похоже на Процедурные, но принципиально отличается.
	// 7. Логические языки программирования - решение задач без алгоритмов... Круть, но хз что такое....
	// 8. Языки сценариев (скрипты) - Не компилируемые ЯПы (вот они) Их прикол в том что они выполняются в какйо то среде, без компиляции будь то Python или консоль Windows.
	// 9. Языки, ориентированные на данные - Языки ориентированы на работу с одним определенным типом данных.
	// Взято со страницы : https://spravochnick.ru/programmirovanie/yazyki_programmirovaniya/klassifikaciya_yazykov_programmirovaniya/
	// 
	// Особенности языков С и С++
	// По поводу С не знаю, но по С++ раскажу:
	// Во-первых, это один из немногих ЯПов низкого уровня.
	// Во-вторых, тут нет Сборщика мусора (delete пишите сами)
	// В-третьих define - нигде не видел такой хераборы..
	// И вишенка на торте, В С++ запихали всё что смогли... Без шуток в нём есть практически всё! Но по факту нет ничерта...
	// 
	// 5)
	// Этапы компиляции программы (Смотрите тут https://server.179.ru/tasks/cpp/total/105.html)
	// Лексический анализ. Последовательность символов исходного файла преобразуется в последовательность лексем.
	// Синтаксический анализ.Последовательность лексем преобразуется в дерево разбора.
	// Семантический анализ.
	// Оптимизация. 
	// Генерация кода.
	// 
	// 6)
	// Программа на С++ состоит из набора инструкций.  (https://metanit.com/cpp/tutorial/2.1.php)
	// Каждая инструкция (statement) выполняет определенное действие. 
	// В конце инструкции в языке C++ ставится точка с запятой (;). Данный знак указывает компилятору на завершение инструкции.
	//	Инструкции
	//	Функция main
	//	Директивы препроцессора
	//	Комментарии
	// 
	// Файлы кода программы
	// *.cpp - исходники
	// *.h - заголвочные файлы
	// *.sln - файлы IDE VisualStudio
	// Но помните есть ещё "сборка" вашей программы или же "Build" Файлы сборки лежат в папке Debug или Release (По умолчанию Debug)
	// А ещё есть папочка Bin (Вроде как должна быть... хм...)
	// 
	// 7)
	// Понятия «идентификатор», «переменная», «константа» и «тип данных»
	// https://intuit.ru/studies/courses/3632/874/lecture/14319?page=2
	// Идентификатор - Имя чего либо: функции, переменной, типа данных и тд.
	// Переменная - ну... переменная...
	// Константа - Ну константа..
	// Типы данных - базовые int float... пользовательские(классы) string и тд.
	// Модификаторы и спецификаторы переменных const, unsigned, short, long...
	// 
	// 8)
	// cin и cout, а ещё есть cerr - для вывода ошибок (лол не знал)
	// 
	// 9)
	// Все стандартные операции языка С\С++ (Операторы)
	// Ну вы же их все помните? + - * / % ^ & | && || ( ) >> << ? : ! = += *= ... 
	// А, ещё есть операторы . -> но они юзаются уже в ООП
	// 
	// Тема 3. Базовые конструкции языка программирования
	// 
	// 10)
	// Ветвление. Операторы ветвления.
	// if - else, switch - case, <statment> ? <if true> : <if false>
	// 
	// 11)
	// Циклы. Операторы циклов.
	// for, while, do wile, for (<iterator> : <array>) - аналог foreach
	// 
	// 12)
	// Операторы безусловного перехода
	// return, break, continue, goto (формально есть, но юзать не этично!)
	// 
	// 13)
	// Преобразования типов данных
	// Ну тут изи, некоторые типы можно преобразовать в другой. (любой базовый можно преобразовать в другой базовый)
	// Кароче

	int a = 0;
	bool b = a;
	char c = b;
	double d = c;

	//e... мдя почти

	float f = d;

	// Для базовых типов никакой магии..
	// Но как дело дойдёт до пользовательских классов... О да начинается то самое)
	// Ну к примеру:

	string s = "Hello world!";
	char* c_s = (char*)s.c_str();

	// Весело, неправдали...
	// Вот это -> (char*) - оператор явного преобразования в тип char*
	// 
	// Тема 4. Массивы переменных
	// 
	// 14)
	// Понятие «массив переменных». Механизм работы массива. Одномерные и многомерные массивы.
	/* Нууу, тут можете поднятся выше и глянуть метод */ Arrays(); //В нём я доходчиво всё раскидал...
	// Но, если вам лень...
	// Массив это такая штука в которой лежит несколько переменных, неожиданно..

	// Одномерный массив
	int arr[] = {5, 3, 2};

	// И зачем же их придумали? А для простоты работы с большим числом переменных и для того чтобы не нарушать DRY
	// Кароче одни плюсы!
	// Как же оно работает, да просто, есть имя массива, и обращаясь по этому имени мы можем получить доступ ко всем его переменным.
	arr[0]; // >> 5
	// В памяти эта штука лежит неразрывно, каждый элемент друг за другом.
	
	// Двумерный массив
	int arrs[2][3] = {
		{1, 2, 3},
		{4, 5, 6}
	};
	// А зачем нужен двумерный массив?
	// Ну чтобы обращатся к нескольким массивам по одному имени. логично? - логично!
	// В памяти эта штука вроде должна лежать одним большим прямоугольником.
	// строчка за строчкой, элемент за элементом.
	// 
	// 15) 
	// Метод сортировки массива «пузырьком».
	// Проще простово!

	const int size = 7;
	int arr1[size] = { 10, 9, 8, 7, 6, 5, 4 };
	for (int iter = 0; iter < size - 1; iter++)
	{
		for (int i = 0; i < size - iter - 1; i++)
		{
			int* left = &arr1[i];
			int* right = &arr1[i + 1];
			if (*left > *right)
			{
				int temp = *left;
				*left = *right;
				*right = temp;
			}

		}
	}

	for (int i = 0; i < size; i++)
		cout << arr1[i] << ' ';

	// ТАДАААМ!
	// Самый простейший алгоритм!
	// 
	//Тема 5. Символьные строки
	/* А вот и строки... сразу хочу вас отправить сюда -> */ Strings(); // А то что добру проподать!
	// Но на самом деле строки всё теже массивы переменных...
	// Просто типа char
	// 
	// 16) 
	// Различия понятий «символьная константа», «символьная строка» и просто «массив символов».Способы ввода / вывода строк.
	
	// Константа
	const char C = 'c';
	// Строка
	string String = "Hello world!";
	// Массив символов
	char char_arr[] = "Hello world!";
	// Ввод вывод можно осуществлять через cin и cout
	// А можно через getline, gets_s, scanf_s, printf_s и прочие...
	// 
	// 17) Функции обработки строк: копирование и конкатенация строк.
	// 18) Функции обработки строк: определение длины строки и сравнение строк.
	// 19) Функции обработки строк : поиск символа в строке.
	// 20) Функции обработки строк : выделение из строки других строк, разделенных некоторыми символами.
	// 21) Тип string.Работа со строкой типа string.
	// 
	// Вы это уже должны были просмотреть в Strings()!
	//
	// Тема 6. Функции
	// Так, вот это разбирается в самом начале файла, листайте туда ^
	// 
	// 22) Функция. Объявление и выполнение функции. Возвращаемое значение.
	// <return type> <func name> (<args>) {<func body>} - Объявление
	// <func name>(<args>) - Вызов
	// 
	// 23) Функция. Прототип функции. Виды функций.
	// Прототип - <return type> <func name> (<args>);
	// Виды... Оу, а вот тут опять косяк преподов, эту тему мы не разобрали до конца!
	// Кароче есть функции и процедуры(не возвращают значение), это во-превых 
	// так же можно разделить на функции с аргументами и без них
	// Есть ещё такая штука как шаблонная функция (не проходили, и тема эта слегка сложная для понимания)
	// А так же не забуду упоминать Анонимную функцию, её прикол в том что её не надо объявлять, давать её имя и прочее, вызов и объявление происходит одновременно (ещё сложнее для понимания)
	// Ну и вишенка на торте! Методы - функции объекта (класса) а вы что думали? это не одно и тоже!
	// Кароче тема мутненькая, но думаю хватит градации по функциям и процедурам, а ну и рекурсивные ^_^ о них ниже
	// 
	// 24) Функция. Параметры функции. Значение по умолчанию. Передача аргументов в функцию по значению и по ссылке.
	// Параметры, или же аргументы, вроде одно и тоже но всёже нет
	// Параметры - пишутся в прототипе
	// Аргументы - передаются при вызове
	// (Да я сам их путаю)
	// 
	// Значение по умолчанию делается очень просто
	// void func(int a = 0);
	// И всё, теперь можно вызвать её как func(10) так и func() (в таком случае a = 0)
	// 
	// Передача аргументов:
	// По значению: (int a)
	// По ссылке: (int& a)
	// По указателю: (int* a)
	// 
	// 25) Передача массива в функцию. 
	// Ну как бы тут два стула:
	// Как указатель: (int* mass)
	// Как массив: (int mass[])
	// Нюанс в том что (int& mass[]) - нельзя!
	// а (int*& mass) - можно
	// 
	// 26) Аргументы функции main().
	// Тут тоже не сложно
	// int main(int argc, char *argv[])
	// конечно можно и так: int main(int foo, char *bar[])
	// Или даже так: int main(int a, char *b[]) 
	// Но принято писать: argc, argv, где первый - размер второго, а второй - массив аргументов программы
	// Вопрос, а нафига оно?
	// Врятли вы будите вызывать main() в вашей программе повторно...
	// Но ведь вы вкурсе что именно с неё начинается выполнение программы?
	// А значит ктото вызывает main()..
	// И этот ктото - Операционная система(после получения соответствующей комманды от пользователя)
	// Рассмотрим их:
	// Двойной клик - запуск без аргументов(чаще всего)
	// Запуск через консоль - вот тут можно и аргументы добавить такие какие вам угодно
	// Запуск программы через "Открыть с помощью..." в таком случае в аргумент будет передан файл, который вы хотите открыть вашей программой
	// 
	// А теперь как это выглядит
	// Отрываем консоль винды, переходим в папку Debug (в консоли конечно) коммандой cd C:/.../Debug
	// Теперь пусть наша программа компилируется в файл Prog.exe и всё что она будет делать - писать аргументы
	// 
	// Выполним комманду в консоли: Prog.exe
	// 
	// Ну, получим тишину в эфире... тк аргументов нет и программа молчит
	// 
	// Теперь выполним: Prog.exe Hello world !
	// У нас 3 аргумента: "Hello", "world", и "!"
	// 
	// А теперь попробуем открыть текстовый документ через нашу программу:
	// Prog.exe SomeText.txt
	// 
	// Пграмма ответит SomeText.txt 
	// (Так же как если мыбы сделали это через контекстное меню винды)
	// 
	// 27) Область видимости переменных. Виды переменных. Сокрытие переменных.
	// Так, вот тут весело, но должно быть понятно на интуитивном уровне
	// Глобальные переменные доступны в любой точке кода
	// Локальные только локально
	// Но что значит локально?
	// а вот что:

	{ int a = 0; }

	// Ничего не смущает?
	// Ну например то что я уже использовал переменную "а"?
	// 
	// хорошо, а вот ещё фокус:
	
	{int a; {int a; {int a; } } } 
	// могу продолжать до бесконечности...
	// Но что это такое? ну в нашем случае это <неименованная область>
	// Что же тогда именованная? ну namespace что ещё то -_- 

	std::cout << SPACE_A::a;
	// Знакомый синтаксис? Ну лан не парьтесь это мы ещё не проходили, забудте то что говорил выше
	// 
	// Итак, локальная область, сюда относится тело функции, условных операторов, операторов ветвления и прочего...

	if (true) { int a = 3; };
	// Например вот ^ 
	
	// 28) Рекурсия. Рекурсивные функции. Составляющие таких функций и особенности их работы.
	// Рекурсия - то что ломает голову всем новичкам, и не даёт заскучать и более опытным
	// А так, штука крайне полезная!
	// Основная идея в вызове функции внутири самой себя(рекурсивно)
	// Забавно да, всё так просто...
	// Но в чём же подвох? да его и нет, воспринимайте рекурсию как аналог цикла, вот и всё...
	//
	//Тема 7. Указатели и ссылки
	// 
	// 29) Указатель. Операторы для работы с указателем. Типы указателей.
	// 30) Указатель.Адресная арифметика.
	// 31) Ссылки.Отличия от указателей.Ссылки на указатели.
	// 32) Указатель.Указатели на константы и константные указатели.
	// 33) Указатель.Работа указателей с массивами.
	// 
	// Дробить не буду всё взамосвязанно:
	// Итак что такое указатель? грубо говоря ссылка на переменную

	int* a_ptr = &a; 

	// Кратко по синтаксису: 
	// - & - взятие адреса переменной
	// - * - Извлечение значения по адресу, записанному в переменную
	// int* - тип в котором int - тип переменной на которую будет он указывать 
	// тобеш, звёздочка в int* и просто * неимеют ничего общего!
	// так же как и оператор &a, амперсант в int&, и батовое a & a
	// НЕ ПУТАЙТЕ!
	// 
	// Так, а что такое ссылка?
	// ну, по сути тоже самое что и указатель... да, так, только с более удобным синтаксисом
	
	int& a_ref = a;

	// Вот только с сылкими не выполняется адресная арифметика.
	// Поясняю: У нас есть указатель, если мы сделаем так: a_ptr++ то он уже будет указывать на следующую ячейку в памяти.
	// В случае с ссылкой (a_ref++) мы увеличим сначение переменной "а" на 1, тоесть равносильно а++
	// 
	// Ну, здорово, но зачем адресная арифметика?
	// Вы же помните как массивы в памяти лежат?
	// Ну вот, если мы возмём адрес первого элемента, то используя его и число элементов в массиве мы сможем проитерироваться по массиву:
	
	// Массив символов для примера
	char test_mass[] = { 'a', 'b', 'c', '\0' };
	for (char* c = &test_mass[0]; c < &test_mass[0] + strlen(test_mass); c++)
		cout << c;
	// Но можно и так
	for (char* c = begin(test_mass); c < end(test_mass); c++)
		cout << c;
	// или даже так
	for (char c : test_mass)
		cout << c;

	// Тема 8. Указатели и ссылки на функции
	// Так, вот эту тему я сам не юзал, и нам про неё вроде в скользь сказали..
	// Читал вот эту статейку: https://ravesli.com/urok-104-ukazateli-na-funktsii/
	// Итак, синтаксис похож на обычные указатели и ссылки, с некием исключением...
	
	int foo();
	int(*foo_ptr)();
	foo_ptr = foo;
	void bar(int);
	void (*bar_ptr)(int) = bar;
	// В данном случае void обязателен так же как и int в скобочках
	// И учтите что сделать foo_ptr = bar - нельзя! у них разные прототипы!
	// Да вспомнил, об этом я как то забыл сказать, упс, кароче у функции int a(); и int b(); - абсолётно одинаковые прототипы! 
	// Прототип зависит от количества и типов аргументов + возвращаемое значение
	// Ну а теперь мы можем делать так:

	foo_ptr();
	bar_ptr(6);

	// Мдааа, прям убер фича, без которой мы жить не могли...
	// Но это цветочки, смотрите дальше!
	
	int Foo(int (*)(int), int);

	cout << Foo(foo1, 1) << endl;
	cout << Foo(foo2, 1) << endl;

	// Занятно да?
	// Иногда может быть полезно...
	// Ну и ссылки... Синтаксис похожий:

	int(&foo_ref)() = foo;

	// Но это не всё, помните прототипы?
	// Ну вот есть такая штучка:
	
	typedef bool(&ValidateInt)(int);

	// Ну и фича для С++ 11 и выше
	
	using ValidateFloat = bool(&)(float);

	// Так, а что же это нам даёт?
	// Нууу вот что:

	bool Bar(int, ValidateInt);
	bool BAR(float, ValidateFloat);

	cout << Bar(5, bar1) << endl;
	cout << BAR(0.5, bar2) << endl;

	// Тема 9. Работа с памятью программы
	// Чтож последняя тема... Я честно подзаебался уже всё это печатать, но надеюсь это хоть ктото прочтёт..
	// Итак, память 
	// 36)Сегменты памяти, используемые программой. Динамически распределяемая область памяти.
	// Итак, привет глухой лес... 
	// Вроде мы имеем 4 сегмента  стек, куча, данные и код. https://coderoad.ru/32922829/Сегменты-Памяти
	// А потом заходим на другую статью и там уже другое https://ravesli.com/urok-105-stek-i-kucha/#toc-0
	//  Сегмент кода (или «текстовый сегмент»), где находится скомпилированная программа. Обычно доступен только для чтения.
	//	Сегмент bss(или «неинициализированный сегмент данных»), где хранятся глобальные и статические переменные, инициализированные нулем.
	//	Сегмент данных(или «сегмент инициализированных данных»), где хранятся инициализированные глобальные и статические переменные.
	//	Куча, откуда выделяются динамические переменные.
	//	Стек вызовов, где хранятся параметры функции, локальные переменные и другая информация, связанная с функциями.
	// И потом вспоминаем что С++ может и регистры трогать...
	// Ну тут думаю главное что:
	//	в стеке лежит порядок вызовов функций и наши не динамические переменные
	//	в куче все динамические переменные
	// Этого хватит
	// В общем приятного чтения статьи номер два, а я еду дальше
	// 
	// Для следующих двух вот статейка http://www.c-cpp.ru/funkcii/dinamicheskoe-vydelenie-pamyati
	// 37) Функции динамического распределения памяти языка С.
	// calloc(), malloc(), free() и realloc() 
	// 38) Функции динамического распределения памяти языка С++.
	// new, delete, delete[], delete[][]...
	// 
	// 39)Динамические массивы.
	// Ну, тут я уже упоминал, это просто массивы через указатели: int* arr = new int[] {1,2,3};
	// 
	// 40) Поразрядные операции.
	// https://metanit.com/cpp/tutorial/2.8.php
	// Ну а этому была посвещена 6-я практика, там всё вполне явно расписано
	//	& : поразрядная конъюнкция (операция И или поразрядное умножение). Возвращает 1, если оба из соответствующих разрядов обоих чисел равны 1
	//	| : поразрядная дизъюнкция(операция ИЛИ или поразрядное сложение).Возвращает 1, если хотя бы один из соответствующих разрядов обоих чисел равен 1
	//	^ : поразрядное исключающее ИЛИ.Возвращает 1, если только один из соответствующих разрядов обоих чисел равен 1
	//	~ : поразрядное отрицание или инверсия.Инвертирует все разряды операнда.Если разряд равен 1, то он становится равен 0, а если он равен 0, то он получает значение 1.
	// 
	//	<< : Сдвиг влево
	//	>> : Сдвиг вправо
	// (не путайте с: cin >> a; cout << a; это другое!)
}

void Exam_Examples()
{
	Part_1();
}

#pragma endregion

#pragma endregion

#pragma region Второй семестр
// Привет, с возвращением в учебную деятельность!
// Как вам первая лекция? Сложно? чтож, топерь мой черёд делится экспириенсом.
// Итак по порядку...
// Енамы. Что это и с чем его едят:

// Пробный енам, не имеющий никакого смысла, просто демонстирирует синтаксис
enum TestEnum
{
	e1,
	e2,
	e3
} 
// А вот это уже экземпляр енама, причём в глобальной области видимости
global_test1;
// Этот экземпляр тоже в глобальной области видимости
TestEnum global_test2;

// Второй пробный енам, константы которого не доступны вне енама (Поясню в коде наже)
enum class TestEnum2
{
	E1,
	E2,
	E3
} global_test3;

// Енам базовых цветов
enum class Color
{
	Red,
	Green,
	Blue,
	White,
	Black,
};

void Enums()
{
	// Вуаля! Но так не хорошо..
	global_test1 = e1;
	global_test2 = e2;

	// Я настаиваю чтобы вы задавали значения енамам вот так!
	TestEnum local_enum = TestEnum::e1;

	// Итак, что даёт приписка class?
	// ну для начала она скравает константы енама
	// global_test3 = E1; // Вот так уже не получится

	// А значит единственный способ обратится к ним отстаётся тот который я вам и рекомендую
	global_test3 = TestEnum2::E3;

	// Чтож давайте пример кода посмотрим.
	// Задача, ввести с клавиатуры цвет, и вывести его код на экран. Да можно эту задачу решить без енама, 
	// но учтите, это потому что у нас нет графического интерфейса, по хорошему ввод мог осуществлятся с помощью выпадающего списка

	Color color;
	int list_number;
	cout << "Красный	: 1\n";
	cout << "Зелёный	: 2\n";
	cout << "Синий	: 3\n";
	cout << "Белый	: 4\n";
	cout << "Чёрный	: 5\n";
	cout << "Введите код цвета из списка:";
	cin >> list_number;
	color = (Color)(list_number-1);

	string code;
	switch (color)
	{
	case Color::Red:
		code = "FF0000";
		break;
	case Color::Green:
		code = "00FF00";
		break;
	case Color::Blue:
		code = "0000FF";
		break;
	case Color::White:
		code = "FFFFFF";
		break;
	case Color::Black:
		code = "000000";
	default:
		break;
	}
	cout << "Код цвета = " << code << endl;

	// Итак, с енамами пока всё, да можно их юзать иначе, менять их номера но зачем? их оснавная роль - ключ в switch case
}

// Чтож, структуры, первый шаг к ООП.
// А именно то что в одной переменной инкапсулируются некоторые связанные данные.
// Я сказал инкапсулируются? чёрт, это из ооп, ну не суть. В общем в одной переменной содержатся некоторые данные, остальное как дойдём до 3х парадигм ООП.

// Демонстрационная структура
struct Demo
{
	int a;
	bool b;
	char c;
	double d;
	enum class E
	{
		demo1,
		demo2,
		demo3
	} e;
	float f;
};

struct Address 
{
	int House_Number;
	string Street;
	string Sity;
	string Country;
	bool IsPrivate_House;
	int Floor_Number;
	int Flat_Number;
};

struct PersonData 
{
	struct 
	{
		string Name;
		string SecondName;
		bool Has_MiddleName;
		string MidleName;
	} FIO;
	int Age; 
	enum class PersonGender
	{
		Man,
		Woman,
		Other
	} 
	Gender; 
	struct 
	{
		Address Living_Address;
		char Phone[12];
		string EMail;
	} 
	Contacts;
};

void Structs()
{
	// Чтож, вот экземпляр структуры Demo.
	Demo d1;
	d1.a = 1;
	d1.b = true;
	d1.c = '\0';
	d1.d = 1.1;
	d1.e = Demo::E::demo1;
	d1.f = 2.2f;

	// А вот его брат близнец
	Demo d2 { 1, true, '\0', 1.1, Demo::E::demo1, 2.2f };
	// Экземпляры d1 и d2 эквиволентны и значения их полей равны... Я опять назвал термин из ООП... 
	// Хорошо, Поле - это такая переменная, которая хранится внутри экземпляра структуры или класса. Да это переменная, но правельнее называть её полем.

	// Чтож теперь перейдём от того как можно, к тому как надо =)

	// Закрепим знания

	// Размер массива
	const int size = 3;
	// Массив данных
	PersonData persons_list[size]
	{
		{{"Иван", "Иванов", true, "Иванович"}, 24, PersonData::PersonGender::Man, {{2, "Иванова", "Москва", "Россия", false, 2, 21}, "89248831204", "Ivanov@mail.ru"}},
		{{"Ирина", "Сидорова", true ,"Павловна"}, 20, PersonData::PersonGender::Woman, {{2, "Победы", "Воронеж", "Россия", false, 12, 34}, "89248831204", "Sidorova@gmail.com"}},
		{{"Stive", "Jobs" ,false}, 36, PersonData::PersonGender::Man, {{1, "Street", "Washington", "America", true}, "89248831204", "Microsoft.com"}},
	};

	// Цикл Foreach
	for (PersonData person : persons_list) // Итерируемая персона
	{
		// Вывод на экран ФИО
		cout << "Фио:\n\t" << person.FIO.SecondName << "\t" << person.FIO.Name << "\t" << person.FIO.MidleName << endl;

		// Вывод на экран Возраста
		cout << "Возраст:\n\t" << person.Age << endl;

		// Вывод на экран Пола
		cout << "Пол:\t";
		switch (person.Gender)
		{
		case PersonData::PersonGender::Man:
			cout << "Мужской";
			break;
		case PersonData::PersonGender::Woman:
			cout << "Женский";
			break;
		case PersonData::PersonGender::Other:
		default:
			cout << "Другой";
			break;
		}
		cout << endl;

		// Вывод на экран Адреса
		cout << "Адрес:\n\tСтрана: " << person.Contacts.Living_Address.Country << "\n\tГород: " << person.Contacts.Living_Address.Sity << "\n\tУлица: "
			<< person.Contacts.Living_Address.Street << "\n\tДом: " << person.Contacts.Living_Address.House_Number;
		if (person.Contacts.Living_Address.IsPrivate_House == false)
			cout << "\n\tЭтаж: " << person.Contacts.Living_Address.Floor_Number << "\n\tКвартира: " << person.Contacts.Living_Address.Flat_Number;
		cout << endl;

		// Вывод на экран Телефона
		cout << "Номер телефона:\n\t" << person.Contacts.Phone << endl;

		// Вывод на экран E-mail
		cout << "E-Mail:\n\t" << person.Contacts.EMail << endl;
		cout << endl;
	}
}

namespace OOP
{
	/// Чтож, вот мы и добрались до самого интересного.
	/// Итак, тема близкая к реальности и, возможно, поэтому все её понимают с трудом...
	/// В чём идея? всё в программировании делается изза везких причин.
	/// Идея в том чтобы разделить код на модули, каждый из которых выполняет поставленную ему задачу.
	/// Это вроде и на лекции озвучили
	/// Ну, теория это хорошо, но моя стезя - практика
	/// ПРИСТУПИМ!

	/// <summary>
	/// Демо класс, бесполезный - но наглядный
	/// </summary>
	class Demo_Class
	{
		// Не обязательно, но лучше указать. (По умолчанию все поля - private)
		// Итак, что оно делает? Делает оно следующее, всё что находится ниже доступно только внутри методов этого класса
	private:
		/// <summary>
		/// Демо поле, с приватным модификатором доступа, значение по умолчанию := 0
		/// </summary>
		int _demo_field = 0;
		// Здесь приватное пространство кончается, и начинается публичное.
		// Это значит что все поля ниже доступны так же и вне методов класса
	public:
		/// <summary>
		/// Демо поле, с публичным модификатором доступа
		/// </summary>
		int Demo_Field;

		// И да, сектора модификаторов доступа могут дублироваться
	private:
		/// <summary>
		/// Демо метод, модификатор доступа private
		/// </summary>
		int Demo_Method()
		{

		}
	public:
		/// <summary>
		/// Демо метод, модификатор доступа public
		/// </summary>
		int DemoMethod()
		{

		}
	};
	/// Итак, новые термины: 
	/// Метод - Функция внутри класса
	/// Поле - Переменная внутри класса
	/// Если ждёте от меня 100% точности, то простите, теория не моё.

	/// Чтож, демонстрировать синтаксис - хорошо, но яснее не стало
	/// Перейдём к наглядному, популярный премер класс "Животные"
	/// Но я возьму нечто другое =)
	/// Компьютер, не... Калькулятор - просто... Видео камера, хммм... А давайте сделаем свой класс String?
	/// Вполне возможно это будет будущее задание по лабам =)

	/// ПРИСТУПИМ (Или нет...)

#pragma region Try To String

	/// <summary>
	/// Класс реализующий интерфейс взаимодействия со строкой
	/// </summary>
	class String
	{
	private:
		char* data = NULL;
		int len;

		void Copy(const char copy[])
		{
			if (data)
				delete data;

			len = strlen(copy);
			this->data = new char[len + 1];
			for (int i = 0; i < len; i++)
				this->data[i] = copy[i];
			this->data[len] = '\0';
		}

		friend ostream& operator << (ostream&, String&);
		friend istream& operator >> (istream&, String&);

		friend String operator +(const String&, const String);
		friend String operator +(const String&, const char*);

		friend void operator +=(String&, const String);
		friend void operator +=(String&, const char*);

	public:
		String()
		{
			len = 0;
			data = new char[len];
		}

		String(const char* data)
		{
			Copy(data);
		}

		String(const String& copy)
		{
			Copy(copy.data);
		}


		~String()
		{
			if (data)
				delete data;
		}
	};

	String operator + (const String& str1, const char* str2)
	{
		int len = str1.len + strlen(str2);
		String result;
		result.len = len;
		result.data = new char[len + 1];
		for (int i = 0; i < len; i++)
		{
			if (i < str1.len)
				result.data[i] = str1.data[i];
			else
				result.data[i] = str2[i + str1.len];
		}
		result.data[len] = '\0';

		return result;
	}

	String operator + (const String& str1, const String str2)
	{
		return str1 + str2.data;
	}

	void operator +=(String& str1, const String str2)
	{
		str1 = str1 + str2;
	}

	void operator += (String& str1, const char* str2)
	{
		str1 = str1 + str2;
	}

	ostream& operator << (ostream& stream, String& str)
	{
		stream << str.data;
		return stream;
	}

	istream& operator >> (istream& stream, String& str)
	{
		stream.getline(str.data, 255);
		return stream;
	}

	void String_Demo()
	{
		String str;
		str = "Hello";
		String str1 = str;
		cout << str << endl << str1 << endl;
		cin >> str;
		cout << str << endl << str1 << endl;
	}
#pragma endregion

	/// Нужно чтото попроще, и желательно с более простыми перегрузками, а лучше и вовсе без них...
	/// Калькулятор... А что?
	/// (Снова мимо)

#pragma region Try to Calculator

	static class Calculator
	{
	private:
		enum class Operation_Type
		{
			Addition,
			Subtraction,
			Multiplication,
			Division
		};

		struct Operation
		{
			union Operand
			{
				double arg;
				Operation* operation = NULL;
			} left, right;
			Operation_Type type;
			bool has_result;
			double result;
		};

		static int operations_log_count;
		static Operation* operations_log;
	public:
		static double Calculate(const char* data)
		{
			int len = strlen(data);
			Operation operation;
			double number = 0;
			int under_zero = 1;
			for (int i = 0; i < len; i++)
			{
				char c = data[i];
				if ('0' <= c && c <= '9')
				{
					int i = c - '0';
					if (under_zero == 1)
						if (number == 0)
							number = i;
						else
						{
							number *= 10;
							number += i;
						}
					else
					{
						number += (double)i / under_zero;
						under_zero *= 10;
					}
				}
				else if (c == '.' || c == ',')
					under_zero = 10;
				else if (c == '+')
				{
					operation.left.arg = number;
					number = 0;
					operation.type = Operation_Type::Addition;
				}
			}
			cout << number << endl;
			return number;
		}
	};
	void Calculator_Demo()
	{
		Calculator::Calculate("12,123 + ");
	}

#pragma endregion

	/// Вот честно, хочется показать наглядный пример, и так чтобы он был близок к реальным задачам
	/// Да можно банально и просто животные или машину/ракету но энто не то...
	/// А что если понг в консоли?
	/// Хм... а почему нет? Лутс гоу!
	/// мдя... грёбаный С++ нихуя толком не сделать без танца с бубном и чтения тонны документации...

#pragma region Try to pong

	class Console_PongGame
	{
		enum class Game_Status
		{
			Play,
			Pause,
			Finish
		};

		static const int FPS = 30;
		static const int FRAME_DELEY = 200;

	private:
		Game_Status status;

	private:
		static double clockToMilliseconds(clock_t ticks) {
			// units/(units/time) => time (seconds) * 1000 = milliseconds
			return (ticks / (double)CLOCKS_PER_SEC) * 1000.0;
		}
		Console_PongGame()
		{
			status = Game_Status::Play;
		}

		void GameUpdate()
		{

		}

		void Finish_Game()
		{

		}

		void Pause_Update()
		{

		}

	public:
		static void Start_PongGame()
		{
			Console_PongGame game;
			std::chrono::system_clock::time_point a = std::chrono::system_clock::now();
			std::chrono::system_clock::time_point b = std::chrono::system_clock::now();
			while (true)
			{
				// Maintain designated frequency of 5 Hz (200 ms per frame)
				a = std::chrono::system_clock::now();
				std::chrono::duration<double, std::milli> work_time = a - b;

				if (work_time.count() < FRAME_DELEY)
				{
					std::chrono::duration<double, std::milli> delta_ms(FRAME_DELEY - work_time.count());
					auto delta_ms_duration = std::chrono::duration_cast<std::chrono::milliseconds>(delta_ms);
					std::this_thread::sleep_for(std::chrono::milliseconds(delta_ms_duration.count()));
				}

				b = std::chrono::system_clock::now();
				std::chrono::duration<double, std::milli> sleep_time = b - a;

				// Your code here
				system("cls");
				printf("Time: %f \n", (work_time + sleep_time).count());

			}
		}
	};
#define CCOLOR(r,g,b) ((FOREGROUND_RED*(r))|(FOREGROUND_GREEN*(g))|(FOREGROUND_BLUE*(b))|FOREGROUND_INTENSITY)
#define NUM_BUGS  64
#ifndef min
#define min(a, b) (((a) < (b)) ? (a) : (b))
#endif
#ifndef max
#define max(a, b) (((a) > (b)) ? (a) : (b))
#endif
	static COORD      cscr = { 0 };
	static CHAR_INFO* cbuf = NULL;

	void fill_rect(short x, short y, short w, short h, WORD color);
	void put_char(CHAR c, short x, short y, WORD color);
	WORD async_key(HANDLE _in);

	typedef struct {
		short x;
		short y;
		short dx;
		short dy;
		WORD  color;
		CHAR  ch;
	} bug;

	int Test(void) {
		HANDLE cin = GetStdHandle(STD_INPUT_HANDLE);
		HANDLE cout = GetStdHandle(STD_OUTPUT_HANDLE);
		if ((cin == INVALID_HANDLE_VALUE) || (cout == INVALID_HANDLE_VALUE))
			return GetLastError();

		CONSOLE_SCREEN_BUFFER_INFO si;
		if (!GetConsoleScreenBufferInfo(cout, &si))
			return GetLastError();

		si.dwSize.Y /= 7;
		if (!SetConsoleScreenBufferSize(cout, si.dwSize))
			return GetLastError();

		si.srWindow.Bottom = si.dwSize.Y - 1;
		SetConsoleWindowInfo(cout, TRUE, &si.srWindow);

		SetConsoleTitleW(L"Пример двойной буферизации");

		CONSOLE_CURSOR_INFO ci;
		GetConsoleCursorInfo(cout, &ci);
		ci.bVisible = FALSE;
		SetConsoleCursorInfo(cout, &ci);

		cscr = si.dwSize;
		const COORD pos = { 0 };

		cbuf = (CHAR_INFO*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY | HEAP_NO_SERIALIZE, sizeof(CHAR_INFO) * (cscr.X * cscr.Y));
		if (cbuf == NULL)
			return ERROR_OUTOFMEMORY;

		//для примера
		bug bugs[NUM_BUGS];
		const bug* e = bugs + NUM_BUGS;
		for (bug* i = bugs; i != e; ++i) {
			i->ch = (CHAR)(rand() % 4) + 1;
			i->x = rand() % cscr.X;
			i->y = rand() % cscr.Y;
			i->dx = (rand() % 2) ? -1 : +1;
			i->dy = (rand() % 2) ? +1 : -1;
			i->color = CCOLOR(rand() % 2, rand() % 2, rand() % 2);
			if (!i->color)
				i->color = CCOLOR(1, 1, 1);
		}

		//выход клавиша Esc
		while (async_key(cin) != VK_ESCAPE) {
			fill_rect(0, 0, cscr.X, cscr.Y, 0);

			for (bug* i = bugs; i != e; ++i) {

				i->x += i->dx;
				if (i->x < 0 || i->x >= cscr.X) {
					i->x = max(min(i->x, cscr.X - 1), 0);
					i->dx = -i->dx;
				}

				i->y += i->dy;
				if (i->y < 0 || i->y >= cscr.Y) {
					i->y = max(min(i->y, cscr.Y - 1), 0);
					i->dy = -i->dy;
				}
				put_char(i->ch, i->x, i->y, i->color);
			}

			//выводим
			WriteConsoleOutputA(cout, cbuf, cscr, pos, &si.srWindow);
			Sleep(40);
		}

		HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, cbuf);
		return 0;
	}

	//прямоугольник
	void fill_rect(short x, short y, short w, short h, WORD color) {
		int p;
		x = min(max(0, x), cscr.X);
		y = min(max(0, y), cscr.Y);
		w = min(cscr.X, x + w);
		h = min(cscr.Y, y + h);
		for (short i = y; i < h; ++i) {
			for (short j = x; j < w; ++j) {
				p = i * cscr.X + j;
				cbuf[p].Char.AsciiChar = '\0';
				cbuf[p].Attributes = color;
			}
		}
	}

	//символ
	void put_char(CHAR c, short x, short y, WORD color) {
		if ((x >= 0 && x < cscr.X) && (y >= 0 && y < cscr.Y)) {
			int i = y * cscr.X + x;
			cbuf[i].Char.AsciiChar = c;
			cbuf[i].Attributes = color;
		}
	}

	WORD async_key(HANDLE _in) {
		INPUT_RECORD rs[128];
		DWORD n;
		if (!PeekConsoleInput(_in, rs, 128, &n))
			return WORD(~0);

		for (DWORD i = 0; i < n; ++i) {
			if ((rs[i].EventType == KEY_EVENT) && rs[i].Event.KeyEvent.bKeyDown) {
				FlushConsoleInputBuffer(_in);
				return rs[i].Event.KeyEvent.wVirtualKeyCode;
			}
		}
		return WORD(~0);
	}

#pragma endregion
	/// Чтож... я бездарный С++ прогер, получается, если не могу придумать нечто дельное и реализовать его на сраных плюсах
	/// Ну, последняя попытка, и я на неё очень расчитываю!
	/// Сделаем редактор космической ракеты!

	void Chainge_ConsolePixel(SHORT line, SHORT num, char ch)
	{
		HANDLE cons = GetStdHandle(STD_OUTPUT_HANDLE);
		if (cons != INVALID_HANDLE_VALUE)
		{
			CONSOLE_SCREEN_BUFFER_INFO old;
			GetConsoleScreenBufferInfo(cons, &old);
			SetConsoleCursorPosition(cons, { num, line });
			std::cout << ch;
			SetConsoleCursorPosition(cons, old.dwCursorPosition);
		}
	}

	class Console_SpaceShip_Editor
	{
		struct Point2
		{
			int x;
			int y;
		};

		static class RocketParts
		{
		public:
			enum class Stage_Type
			{
				NoseCone,
				Parachute,
				Cockpit,
				FuelTank,
				Engine,
				Decupler
			};

			enum class RadialParts_Type
			{
				Parachute,
				Truster,
			};

			enum class Container_Type
			{
				ConeContainer,
				Flat_Container,
			};

		public:
			struct RocketPart_Sprite
			{
				Point2 Size;
				char** Sprite = NULL;
			};

		public:
			static RocketPart_Sprite* Get_Container_Sprite(Container_Type type, Point2 contained_size)
			{
				Point2 size;
				RocketPart_Sprite* sprite;
				int height = contained_size.y;
				int half_width;
				switch (type)
				{
				case OOP::Console_SpaceShip_Editor::RocketParts::Container_Type::ConeContainer:
					size = { contained_size.x + 2, height + contained_size.x / 2 };
					half_width = size.x / 2;
					sprite = new RocketPart_Sprite{size,
						new char*[size.y]
					};
					for (int i = 0; i < size.y; i++)
					{
						sprite->Sprite[i] = new char[size.x + 1];
						for (int x = 0; x < size.x; x++)
						{
							sprite->Sprite[i][x] = ' ';
						}
						sprite->Sprite[i][size.x] = '\0';
					}
					for (int y = 0; y <= size.x / 2; y++)
					{
						int x1 = half_width - y-1;
						int x2 = half_width + y;
						sprite->Sprite[y][x1] = '/';
						sprite->Sprite[y][x2] = '\\';
					}
					for (int i = size.x / 2; i < size.y-1; i++)
					{
						sprite->Sprite[i][0] = '|';
						sprite->Sprite[i][size.x-1] = '|';
					}
					sprite->Sprite[size.y-1][0] = '\\';
					sprite->Sprite[size.y-1][size.x - 1] = '/';
					break;

				case Container_Type::Flat_Container:
					size = { contained_size.x + 2, height };
					sprite = new RocketPart_Sprite{ size,
						new char* [size.y]
					};

					for (int i = 0; i < size.y; i++)
					{
						sprite->Sprite[i] = new char[size.x + 1];
						for (int x = 0; x < size.x; x++)
						{
							sprite->Sprite[i][x] = ' ';
						}
						sprite->Sprite[i][size.x] = '\0';
					}

					for (int i = 0; i < size.y; i++)
					{
						sprite->Sprite[i][0] = '|';
						sprite->Sprite[i][size.x - 1] = '|';
					}
					break;

				default:

					throw "Wrong type!";
				}
				return sprite;
			}
			static RocketPart_Sprite* Get_RadialPart_Sprite(RadialParts_Type type)
			{
				Point2 size;
				RocketPart_Sprite* sprite;
				switch (type)
				{
				case RadialParts_Type::Parachute:
					size = { 12, 3 };
					sprite = new RocketPart_Sprite{ size,
						new char* [size.y]{
							new char[] {"/|        |\\"},
							new char[] {"||        ||"},
							new char[] {"\\|        |/"},
						}
					};
					break;

				case RadialParts_Type::Truster:
					size = { 14, 3 };
					sprite = new RocketPart_Sprite{ size,
						new char* [size.y]{
							new char[] {"/|          |\\"},
							new char[] {"||#        #||"},
							new char[] {"^^          ^^"},
						}
					};
					break;

				default:
					throw "Wrong type!";
				}

				return sprite;
			}
			static RocketPart_Sprite* Get_Stage_Sprite(Stage_Type type)
			{
				Point2 size{ 0, 0 };
				RocketPart_Sprite* sprite;
				switch (type)
				{
				case Stage_Type::NoseCone:
					size = { 4, 2 };
					sprite = new RocketPart_Sprite{ size,
						new char* [size.y]{
							new char[] {" /\\ "},
							new char[] {"//\\\\"}
						}
					};
					break;

				case Stage_Type::Parachute:
					size = { 4, 2 };
					sprite = new RocketPart_Sprite{ size,
						new char* [2]{
							new char[] {" __ "},
							new char[] {"/||\\"},
						}
					};
					break;

				case Stage_Type::Cockpit:
					size = { 8, 3 };
					sprite = new RocketPart_Sprite{ size,
						new char* [size.y]{
							new char[] {" /####\\ "},
							new char[] {"/|(__)|\\"},
							new char[] {"[||||||]"},
						}
					};
					break;

				case Stage_Type::FuelTank:
					size = { 8, 3 };
					sprite = new RocketPart_Sprite{ size,
						new char* [size.y]{
							new char[] {"[||||||]"},
							new char[] {"||[--]||"},
							new char[] {"[||||||]"},
						}
					};
					break;

				case Stage_Type::Engine:
					size = { 8, 3 };
					sprite = new RocketPart_Sprite{ size,
						new char* [size.y]{
							new char[] {" \\||||/ "},
							new char[] {"  //\\\\  "},
							new char[] {" //||\\\\ "},
						}
					};
					break;
				case Stage_Type::Decupler:
					size = { 8, 1 };
					sprite = new RocketPart_Sprite{ size,
						new char* [size.y]{
							new char[] {"[======]"}
						}
					};
					break;

				default:
					throw "Wrong type!";
				}
				return sprite;
			}
			static void Draw_Part(RocketPart_Sprite part, Point2 top_left_point, Point2 editor_size)
			{
				for (int y = 0; y < part.Size.y; y++)
				{
					for (int x = 0; x < part.Size.x; x++)
					{
						char ch = part.Sprite[y][x];
						int screen_x = top_left_point.x + x;
						int screen_y = top_left_point.y + y;
						bool is_h_edge = screen_x < 0 || screen_x >= editor_size.x;
						bool is_v_edge = screen_y < 0 || screen_y >= editor_size.y;
						if (ch == ' ' || is_h_edge || is_v_edge)
							continue;
						Chainge_ConsolePixel(screen_y, screen_x, ch);
					}
				}
			}
		};

		struct Part_ListItem
		{
			RocketParts::RocketPart_Sprite* Main_Part = NULL;
			RocketParts::RocketPart_Sprite* Radial_Part = NULL;
			RocketParts::RocketPart_Sprite* Container = NULL;
			Part_ListItem* Next_Part = NULL;
			~Part_ListItem()
			{
				if (Main_Part)
					delete Main_Part;
				if (Radial_Part)
					delete Radial_Part;
				if (Container)
					delete Container;
				if (Next_Part)
					delete Next_Part;
			}
		};

		class Parts_List
		{
		private:
			Part_ListItem* _first = NULL; 
			Part_ListItem* _last = NULL;
			int _count = 0;

		public:
			Parts_List() {};
			~Parts_List()
			{
				if (_first)
					delete _first;
			}

		private:
			bool Index_IsOutOfRange(int index)
			{
				return index > _count + 1 || index < 0;
			}

		public:
			int Get_Count()
			{
				return _count;
			}
			void Add(Part_ListItem* item)
			{
				if (_last)
					_last->Next_Part = item;
				else
					_first = item;

				_last = item;
				_count++;
			}

			Part_ListItem* operator [](int index)
			{
				if (Index_IsOutOfRange(index))
					throw "Index out of range!";

				Part_ListItem* item = _first;
				for (int i = 0; i < index; i++)
				{
					item = item->Next_Part;
				}
				return item;
			}

			void Remove(int index)
			{
				if (Index_IsOutOfRange(index - 1))
				{
					delete _first, _last;
					_first = _last = NULL;
					return;
				}

				Part_ListItem* previous = this->operator[](index-1);

				if (Index_IsOutOfRange(index + 1))
				{
					delete _last;
					_last = previous;
					return;
				}

				Part_ListItem* next = this->operator[](index + 1);
				
				delete previous->Next_Part;
				previous->Next_Part = next;
			}
		};

	private:
		const Point2 Editor_Size{ 50, 50 };
		const Point2 Border_Size{1, 1};
		const char Border_H = '|';
		const char Border_V = '-';
		const char Border_C = '#';
	private:
		Parts_List _parts;
	private:

		void Update_Editor()
		{
			system("cls");
			for (int y = -Border_Size.y; y < Editor_Size.y + Border_Size.y; y++)
			{
				for (int x = -Border_Size.x; x < Editor_Size.x + Border_Size.x; x++)
				{
					bool is_h_edge = x < 0 || x >= Editor_Size.x;
					bool is_v_edge = y < 0 || y >= Editor_Size.y;
					if (is_h_edge)
						if (is_v_edge)
							cout << Border_C;
						else
							cout << Border_H;
					else if (is_v_edge)
						cout << Border_V;
					else
						cout << ' ';
				}
				cout << endl;
			}
			Build_Ship();
		}

		void Build_Ship()
		{
			int curent_y = Editor_Size.y + Border_Size.y - 1;
			int center_x = (Editor_Size.x + Border_Size.x) / 2;
			for (int i = 0; i < _parts.Get_Count(); i++)
			{
				Part_ListItem* part = _parts[i];
				if (part->Container)
				{
					RocketParts::Draw_Part(*part->Container, Point2{ center_x - part->Container->Size.x / 2, curent_y - part->Container->Size.y }, Editor_Size);
				}

				if (part->Main_Part)
				{
					RocketParts::Draw_Part(*part->Main_Part, Point2{ center_x - part->Main_Part->Size.x / 2, curent_y - part->Main_Part->Size.y }, Editor_Size);

					if (part->Radial_Part)
					{
						RocketParts::Draw_Part(*part->Radial_Part, Point2{ center_x - part->Radial_Part->Size.x / 2, curent_y - part->Radial_Part->Size.y }, Editor_Size);
					}
					curent_y -= part->Main_Part->Size.y;
				}
			}
		}

	public:
		void Start()
		{
			_parts = Parts_List();
			_parts.Add(new Part_ListItem{ RocketParts::Get_Stage_Sprite(RocketParts::Stage_Type::Engine) });
			_parts.Add(new Part_ListItem{ RocketParts::Get_Stage_Sprite(RocketParts::Stage_Type::FuelTank) });
			_parts.Add(new Part_ListItem{ RocketParts::Get_Stage_Sprite(RocketParts::Stage_Type::FuelTank) });
			_parts.Add(new Part_ListItem{ RocketParts::Get_Stage_Sprite(RocketParts::Stage_Type::FuelTank), RocketParts::Get_RadialPart_Sprite(RocketParts::RadialParts_Type::Truster) });
			_parts.Add(new Part_ListItem{ RocketParts::Get_Stage_Sprite(RocketParts::Stage_Type::Decupler) });
			_parts.Add(new Part_ListItem{ RocketParts::Get_Stage_Sprite(RocketParts::Stage_Type::Engine), RocketParts::Get_Container_Sprite(RocketParts::Container_Type::Flat_Container, Point2{6, 3}) });
			_parts.Add(new Part_ListItem{ RocketParts::Get_Stage_Sprite(RocketParts::Stage_Type::FuelTank) });
			_parts.Add(new Part_ListItem{ RocketParts::Get_Stage_Sprite(RocketParts::Stage_Type::FuelTank), RocketParts::Get_RadialPart_Sprite(RocketParts::RadialParts_Type::Truster) });
			_parts.Add(new Part_ListItem{ RocketParts::Get_Stage_Sprite(RocketParts::Stage_Type::Decupler) });
			_parts.Add(new Part_ListItem{ RocketParts::Get_Stage_Sprite(RocketParts::Stage_Type::Engine), RocketParts::Get_Container_Sprite(RocketParts::Container_Type::ConeContainer, Point2{8, 11}) });
			_parts.Add(new Part_ListItem{ RocketParts::Get_Stage_Sprite(RocketParts::Stage_Type::FuelTank) });
			_parts.Add(new Part_ListItem{ RocketParts::Get_Stage_Sprite(RocketParts::Stage_Type::Cockpit) });
			_parts.Add(new Part_ListItem{ RocketParts::Get_Stage_Sprite(RocketParts::Stage_Type::Parachute) });


			Update_Editor();
		}
	};
}



int main() 
{
	//Arrays();
	//Strings();
	//HowToCode();
	//Exam_Examples();

	setlocale(LC_ALL, "rus");
	//Enums();
	//Structs();
	//OOP::String_Demo();
	//OOP::Calculator_Demo();
	//OOP::Console_PongGame::Start_PongGame();
	//OOP::Test();
	OOP::Console_SpaceShip_Editor editor;
	editor.Start();
	system("pause");
	return 0;
}